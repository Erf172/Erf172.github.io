{"meta":{"title":"某咸鱼的鱼缸","subtitle":"日常生(翻)活(车)的记录史","description":"你看不到我","author":"这不是lD","url":""},"pages":[],"posts":[{"title":"使用用DS1302写一个简单的时钟","slug":"SDCC-MCS51-DS1302-Clock","date":"2019-09-11T18:33:10.000Z","updated":"2019-09-11T10:54:29.940Z","comments":true,"path":"2019/09/12/SDCC-MCS51-DS1302-Clock/","link":"","permalink":"/2019/09/12/SDCC-MCS51-DS1302-Clock/","excerpt":"用定时器写完时钟后，开发板上的DS1302自然是不能放过，看了半天文档，差不多写出来了，特此记录一下下吧","text":"用定时器写完时钟后，开发板上的DS1302自然是不能放过，看了半天文档，差不多写出来了，特此记录一下下吧 前言一个利用DS1302模块所写的一个简单的时钟，使用的是普中的开发板 只能够实现基本的计时功能 代码 main.c 主程序ds1302.c 驱动ds1302模块led_1602.c 驱动1602液晶 main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include \"led_1602.h\"#include \"ds1302.h\"#include &lt;at89x52.h&gt;uint i=0;void display_time_week(uint cl_week,uint w_local);void display_time_date(uint *timep);void delay (uint xms);uchar dis_wel[]=\"Welcome!\";uchar dis_blog[]=\"www.erf172.tk\";uchar dis_week[]=\"SunMonTueWedThuFriSat\";extern uint *TIME_P;uint time[7]=&#123;0x00,0x51,0x17,0x11,0x09,3,0x19&#125;;void main()&#123; TIME_P=time; _1602_init(); _1602_command(0x80); while(dis_blog[i]!='\\0') &#123; _1602_data(dis_blog[i]); i++; &#125; _1602_command(0xc0); i=0; while(dis_wel[i]!='\\0') &#123; _1602_data(dis_wel[i]); i++; &#125; delay(5000); Ds1302Init(); _1602_command(1); while (1)&#123; Ds1302ReadTime(); display_time_date(TIME_P); &#125;&#125; void display_time_date(uint *timep)&#123; uint i=0; uchar time_display_date[10]=&#123;'2','0',0,0,'/',0,0,'/',0,0&#125;; uchar time_display_clock[8]=&#123;0,0,':',0,0,':',0,0&#125;; uchar time_display_week=0; time_display_date[2]=*(timep+6)/16+'0'; time_display_date[3]=*(timep+6)%16+'0'; time_display_date[5]=*(timep+4)/16+'0'; time_display_date[6]=*(timep+4)%16+'0'; time_display_date[8]=*(timep+3)/16+'0'; time_display_date[9]=*(timep+3)%16+'0'; time_display_clock[0]=*(timep+2)/16+'0'; time_display_clock[1]=*(timep+2)%16+'0'; time_display_clock[3]=*(timep+1)/16+'0'; time_display_clock[4]=*(timep+1)%16+'0'; time_display_clock[6]=*(timep+0)/16+'0'; time_display_clock[7]=*(timep+0)%16+'0'; time_display_week=*(timep+5)%7; _1602_command(0x83); for ( i = 0; i &lt; 10; i++) &#123; _1602_data(time_display_date[i]); &#125; _1602_command(0xc6); for ( i = 0; i &lt; 8; i++) &#123; _1602_data(time_display_clock[i]); &#125; _1602_command(0xc2); _1602_data(time_display_week); display_time_week(time_display_week,0xc2);&#125;void display_time_week(uint cl_week,uint w_local)&#123; _1602_command(w_local); uint j=0; j=cl_week*3; while(j&lt;=cl_week*3+2) &#123; _1602_data(dis_week[j]); j++; &#125; &#125;void delay(uint xms)&#123; unsigned int x,y; for(x=xms;x&gt;0;x--) for(y=110;y&gt;0;y--);&#125; ds1302.h1234567891011121314151617181920212223242526272829303132333435#ifndef __DS1302_H_#define __DS1302_H_#include &lt;at89x52.h&gt;#ifndef uchar#define uchar unsigned char#endif#ifndef uint #define uint unsigned int#endif/* 定义一下nop，延时一个机器周期 */#define __nop() __asm__ (\"NOP\")__sbit __at 0xB4 _DSIO;__sbit __at 0xB5 _RST;__sbit __at 0xB6 _SCLK;void Ds1302Write(uchar ds1302_addr_w, uchar ds1302_data);uchar Ds1302Read(uchar ds1302_addr_r);void Ds1302Init();void Ds1302ReadTime();extern uchar clock_address_w[7];extern uchar clock_address_r[7];#endif ds1302.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include \"ds1302.h\"uint *TIME_P;uchar clock_address_w[7]=&#123;0x80,0x82,0x84,0x86,0x88,0x8a,0x8c&#125;;uchar clock_address_r[7]=&#123;0x81,0x83,0x85,0x87,0x89,0x8b,0x8d&#125;;uchar *clock_address_p;void Ds1302Write(uchar ds1302_addr_w, uchar ds1302_data)&#123; uint i=0; _RST=0; __nop(); _SCLK=0; __nop(); _RST=1; __nop(); for ( i = 0; i &lt; 8; i++) &#123; _DSIO=ds1302_addr_w&amp;0x01; ds1302_addr_w&gt;&gt;=1; _SCLK=1; __nop(); _SCLK=0; __nop(); &#125; for ( i = 0; i &lt; 8; i++) &#123; _DSIO=ds1302_data&amp;0x01; ds1302_data&gt;&gt;=1; _SCLK=1; __nop(); _SCLK=0; __nop(); &#125; _RST=0; __nop();&#125;uchar Ds1302Read(uchar ds1302_addr_r)&#123; uint i=0,ds1302_data_r,temp; _RST=0; __nop(); _SCLK=0; __nop(); _RST=1; __nop(); for(i=0; i&lt;8; i++) &#123; _DSIO = ds1302_addr_r &amp; 0x01; ds1302_addr_r &gt;&gt;= 1; _SCLK = 1; __nop(); _SCLK = 0; __nop(); &#125; __nop(); for ( i = 0; i &lt; 8; i++) &#123; temp=_DSIO; ds1302_data_r= (ds1302_data_r&gt;&gt;1) | (temp&lt;&lt;7); _SCLK=1; __nop(); _SCLK=0; __nop(); &#125; _RST=0; __nop(); _SCLK=1; __nop(); _DSIO=0; __nop(); _DSIO=1; __nop(); return ds1302_data_r;&#125;void Ds1302Init()&#123; uint i=0; Ds1302Write(0x8e,0); clock_address_p=clock_address_w; for ( i = 0; i &lt; 7; i++) &#123; Ds1302Write(*(clock_address_p+i),*(TIME_P+i)); &#125; Ds1302Write(0x8e,0x80);&#125;void Ds1302ReadTime()&#123; uint i=0; clock_address_p=clock_address_r; for ( i = 0; i &lt; 7; i++) &#123; *(TIME_P+i)=Ds1302Read(*(clock_address_p+i)); &#125; &#125; led_1602.h123456789101112131415161718192021222324252627282930#ifndef _LED_1602_H_#define _LED_1602_H_#include &lt;at89x52.h&gt;#ifndef uchar#define uchar unsigned char#endif#ifndef uint #define uint unsigned int#endif__sbit __at 0xA6 _LED_RS;__sbit __at 0xA5 _LED_RW;__sbit __at 0xA7 _LED_E;#define LED_IO P0void _1602_busy();void _1602_init();void _1602_command(uint com);void _1602_data(uint data);#endif led_1602.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include \"led_1602.h\"void _1602_init()&#123; P1=P1&amp;0xf0; _1602_command(0x38); _1602_command(0x0c); _1602_command(0x06); _1602_command(0x01);&#125;void _1602_command(uint com)&#123; _1602_busy(); _LED_RS=0; _LED_RW=0; LED_IO=com; _LED_E=1; _LED_E=0; &#125;void _1602_data(uint data)&#123; _1602_busy(); _LED_RS=1; _LED_RW=0; LED_IO=data; _LED_E=1; _LED_E=0;&#125;void _1602_busy() //忙检测函数，判断bit7是0，允许执行；1禁止&#123; unsigned char sta; // LED_IO = 0xff; _LED_RS = 0; _LED_RW = 1; do &#123; _LED_E = 1; sta = LED_IO; _LED_E = 0; //使能，用完就拉低，释放总线 &#125;while(sta &amp; 0x80);&#125; makefile1234567891011121314151617181920212223242526272829src=$(wildcard ./*.c)target=projectcc=sdcccflags=-mmcs51 --model-large main.hex:main.ihx packihx main.ihx &gt; main.hexmain.ihx: main.c ds1302.rel led_1602.rel $(cc) $(cflags) main.c ds1302.rel led_1602.relds1302.rel:ds1302.c $(cc) $(cflags) -c ds1302.cled_1602.rel:led_1602.c $(cc) $(cflags) -c led_1602.c.PHONY:cleanclean: -rm -rf *.lk *.bin *.asm *.lst *.mem *.rst *.lnk *.rel *.sym *.ihx *.hex *.map 运行截图","categories":[{"name":"MCS-51","slug":"MCS-51","permalink":"/categories/MCS-51/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"/tags/单片机/"},{"name":"写bug","slug":"写bug","permalink":"/tags/写bug/"}]},{"title":"用51单片机写一个简单的时钟","slug":"SDCC-MCS51-Timer-Clock","date":"2019-08-28T20:33:10.000Z","updated":"2019-08-31T03:04:06.625Z","comments":true,"path":"2019/08/29/SDCC-MCS51-Timer-Clock/","link":"","permalink":"/2019/08/29/SDCC-MCS51-Timer-Clock/","excerpt":"学习了一段时间的单片机，觉得自己可以写点东西了，在写了无数个bug后，差不多是可以跑起来了，记录一下下吧。。。","text":"学习了一段时间的单片机，觉得自己可以写点东西了，在写了无数个bug后，差不多是可以跑起来了，记录一下下吧。。。 前言一个利用51的定时中断所写的一个简单的时钟，使用的是普中的开发板 只能够实现基本的计时功能 电路图有 一点丑 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367/** 名称: 利用51单片机的定时器中断编写一个简易时钟* 作者: 这不是lD* 时间： 2019/8/26* 环境： VSCode+SDCC* blog： www.erf172.tk*/#include &lt;at89x52.h&gt;#define uchar unsigned char#define uint unsigned intuint tt=0;uint i;uint time_table[6]=&#123;2000,1,1,0,0,0&#125;;void display_time_day(uint cl_year,uint cl_month,uint cl_date,uint d_local);void display_time_clock(uint cl_hour,uint cl_min,uint cl_sec,uint c_local);void display_time_week(uint cl_week,uint w_local);uint judge_date(uint jd_month,uint jd_year);uint judge_week(uint jd_w_day,uint jd_w_month,uint jd_w_year);void set_time();void _1602_busy();void _1602_init();void _1602_command(uint com);void _1602_data(uint data);#define LED_IO P0__sbit __at 0xA6 _LED_RS;__sbit __at 0xA5 _LED_RW;__sbit __at 0xA7 _LED_E;uchar dis_wel[]=\"Welcome!\";uchar dis_blog[]=\"www.erf172.tk\";uchar dis_set[]=\"SETTIME\";uchar dis_week[]=\"SunMonTueWedThuFriSat\";__sbit __at 0x97 _KEY_P;__sbit __at 0x95 _KEY_D;__sbit __at 0xB5 _KEY_NEXT;int main()&#123; EA=1; //开总中断 TMOD=0x01; TH0=(65536-50000)/256; TL0=(65536-50000)%256; ET0=1; TR0=1; _1602_init(); //初始化1602 _1602_command(0x80); while(dis_blog[i]!='\\0') &#123; _1602_data(dis_blog[i]); i++; &#125; _1602_command(0xc0); i=0; while(dis_wel[i]!='\\0') &#123; _1602_data(dis_wel[i]); i++; &#125; while(tt!=80); _1602_command(0x01); set_time(); tt=0; while (1) &#123; if(tt==20) &#123; tt=0; time_table[5]++; if (time_table[5]==60) &#123; time_table[5]=0; time_table[4]++; if (time_table[4]==60) &#123; time_table[4]=0; time_table[3]++; if (time_table[3]==24) &#123; time_table[3]=0; time_table[2]++; if (time_table[2]==judge_date(time_table[1],time_table[0])) &#123; time_table[2]=1; time_table[1]++; if (time_table[1]==13) &#123; time_table[1]=1; time_table[0]++; &#125; &#125; &#125; &#125; &#125; display_time_day(time_table[0],time_table[1],time_table[2],0x83); display_time_clock(time_table[3],time_table[4],time_table[5],0xc6); uint week=judge_week(time_table[2],time_table[1],time_table[0]); display_time_week(week,0xc2); &#125; &#125;&#125;void set_time()&#123; i=0; uint time_table_simple[6]=&#123;2100,12,31,23,59,59,59&#125;; _1602_command(0x80); while(i&lt;3) &#123; _1602_data(dis_set[i]); i++; &#125; _1602_command(0xc0); while(dis_set[i]!='\\0') &#123; _1602_data(dis_set[i]); i++; &#125; display_time_day(time_table[0],time_table[1],time_table[2],0x86); display_time_clock(time_table[3],time_table[4],time_table[5],0xc8); for ( i = 0; i &lt; 6; i++) &#123; time_table_simple[3]=judge_date(time_table[1],time_table[0])-1; while (_KEY_NEXT) &#123; while (_KEY_P&amp;&amp;_KEY_NEXT&amp;&amp;_KEY_D); //只有在任意一个按键低电平的时候才能进行下一一步操作 if(!_KEY_P) time_table[i]++; if(!_KEY_D) time_table[i]--; if(time_table[i]&gt;time_table_simple[i]||time_table[i]==0&amp;&amp;i&lt;3) time_table[i]=1; if(time_table[i]&gt;time_table_simple[i]&amp;&amp;i&gt;2) time_table[i]=0; display_time_day(time_table[0],time_table[1],time_table[2],0x86); display_time_clock(time_table[3],time_table[4],time_table[5],0xc8); while (!_KEY_P||!_KEY_D); //任意一个键松开时才有反应 if (!_KEY_NEXT) break; &#125; while (!_KEY_NEXT); &#125; _1602_command(0x01);&#125;/* 显示相关 */void display_time_day(uint cl_year,uint cl_month,uint cl_date,uint d_local)&#123; /* 显示年月日 格式为 xxxx-xx-xx */ uint dis_date_table[10]=&#123;0,0,0,0,0x2D,0,0,0x2D,0,0&#125;; //0x2D 为\"=\" uint i=0; /* 转换成ASCII码需要加0x30 */ dis_date_table[0]=cl_year/1000+0x30; dis_date_table[1]=cl_year%1000/100+0x30; dis_date_table[2]=cl_year%1000%100/10+0x30; dis_date_table[3]=cl_year%1000%100%10+0x30; dis_date_table[5]=cl_month/10+0x30; dis_date_table[6]=cl_month%10+0x30; dis_date_table[8]=cl_date/10+0x30; dis_date_table[9]=cl_date%10+0x30; /* 移动当前光标至第一行中间 */ _1602_command(d_local); for ( i = 0; i &lt; 10; i++) &#123; _1602_data(dis_date_table[i]); &#125; &#125;void display_time_clock(uint cl_hour,uint cl_min,uint cl_sec,uint c_local)&#123; /* 显示时间 格式 xx:xx:xx */ uint dis_clock_table[]=&#123;0,0,0x3A,0,0,0x3A,0,0&#125;; uint i=0; /* 转换成ASCII码需要加0x30 */ dis_clock_table[0]=cl_hour/10+0x30; dis_clock_table[1]=cl_hour%10+0x30; dis_clock_table[3]=cl_min/10+0x30; dis_clock_table[4]=cl_min%10+0x30; dis_clock_table[6]=cl_sec/10+0x30; dis_clock_table[7]=cl_sec%10+0x30; /* 移动当前光标至第二行中间 */ _1602_command(c_local); for ( i = 0; i &lt; 8; i++) &#123; _1602_data(dis_clock_table[i]); &#125;&#125;void display_time_week(uint cl_week,uint w_local)&#123; _1602_command(w_local); uint j=0; j=cl_week*3; while(j&lt;=cl_week*3+2) &#123; _1602_data(dis_week[j]); j++; &#125;&#125;/* 判断当前月份有多少天 */uint judge_date(uint jd_month,uint jd_year) &#123; uint jd_date=0; switch (jd_month) &#123; case 1: jd_date=31; break; case 2: &#123; if((jd_year%4==0&amp;&amp;jd_year%100!=0)||jd_year%400==0) jd_date=29; //判断闰年 else jd_date=28; break; &#125; case 3: jd_date=31; break; case 4: jd_date=30; break; case 5: jd_date=31; break; case 6: jd_date=30; break; case 7: jd_date=31; break; case 8: jd_date=31; break; case 9: jd_date=30; break; case 10: jd_date=31; break; case 11: jd_date=30; break; case 12: jd_date=31; break; default: break; &#125; return jd_date;&#125;/* 判断当前日期是星期几 */uint judge_week(uint jd_w_day,uint jd_w_month,uint jd_w_year)&#123; uint Year_Sum=0,Month_Sum=0,This_Year_Month=0,jd_w_week=0; // 1900/1/1 为星期一 Year_Sum=(jd_w_year-1900)+(jd_w_year-1901)/4; for (This_Year_Month = 1; This_Year_Month &lt; jd_w_month; This_Year_Month++) &#123; Month_Sum=Month_Sum+judge_date(This_Year_Month, jd_w_year); &#125; jd_w_week=(Year_Sum+jd_w_day+Month_Sum)%7; return jd_w_week; &#125;/* 驱动1602液晶 */void _1602_init()&#123; P1=P1&amp;0xf0; _1602_command(0x38); _1602_command(0x0c); _1602_command(0x06); _1602_command(0x01);&#125;void _1602_command(uint com)&#123; _1602_busy(); _LED_RS=0; _LED_RW=0; LED_IO=com; _LED_E=1; _LED_E=0; &#125;void _1602_data(uint data)&#123; _1602_busy(); _LED_RS=1; _LED_RW=0; LED_IO=data; _LED_E=1; _LED_E=0;&#125;void _1602_busy() //忙检测函数，判断bit7是0，允许执行；1禁止&#123; unsigned char sta; // LED_IO = 0xff; _LED_RS = 0; _LED_RW = 1; do &#123; _LED_E = 1; sta = LED_IO; _LED_E = 0; //使能，用完就拉低，释放总线 &#125;while(sta &amp; 0x80);&#125;/* 中断 */void exter1() __interrupt 1 &#123; TH0=(65536-50000)/256; TL0=(65536-50000)%256; tt++; &#125; 编译&amp;&amp;烧录使用sdcc -mmcs51 --code-size 8192 --model-medium --opt-code-size 51timer.c编译即可 使用stcgal -P stc89 -p /dev/cu.wchusbserial14330 51timer.ihx烧录进单片机即可 运行截图","categories":[{"name":"MCS-51","slug":"MCS-51","permalink":"/categories/MCS-51/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"/tags/单片机/"},{"name":"写bug","slug":"写bug","permalink":"/tags/写bug/"}]},{"title":"用sdcc&VSCode搭建51单片机开发环境","slug":"SDCC-and-VSCode-MCS51","date":"2019-07-25T11:44:34.000Z","updated":"2019-08-30T12:51:26.907Z","comments":true,"path":"2019/07/25/SDCC-and-VSCode-MCS51/","link":"","permalink":"/2019/07/25/SDCC-and-VSCode-MCS51/","excerpt":"学习了一段时间的单片机，虽然Keil搞单片机是最常见的方案，但总是感觉Keil用着很不习惯在翻了无数次车之后，终于在跑起来了，特此记录一下下吧。。。。","text":"学习了一段时间的单片机，虽然Keil搞单片机是最常见的方案，但总是感觉Keil用着很不习惯在翻了无数次车之后，终于在跑起来了，特此记录一下下吧。。。。 前言众所周知，Keil下搞单片机是最好的选择，但是用起来的体验么。。。。。凡事就是图一个折腾。于是乎，Let’s Go！ 要进行的工作 安装sdcc 安装Visual Studio Code 安装烧录程序 安装ttl下载器的驱动 sdcc简介sdcc (Small Device C Compiler) 是一个应用于单片机的一个交叉编译器，其官网上的解释是这样的 SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO C99, ISO C11) compiler suite that targets the Intel MCS51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80, Rabbit 2000/3000, Rabbit 3000A, TLCS-90), Padauk (pdk14, pdk15) and STMicroelectronics STM8. Work is in progress on supporting the Padauk (pdk13), Microchip PIC16 and PIC18 targets. It can be retargeted for other microprocessors. 为什么不放中文，因为英语水平太差 需要注意的是，sdcc与Keil的语法是有一些不相同的地方的，下面是一些不相同的地方供以参考 SDCC Keil sbit at 0x94 a sbit a=P1^4 0x80 P0^0 0x90 P1^0 0xA0 P2^0 0xB0 P3^0 P1_1 P1^1 __interrupt interrupt 遇事不决双下划线 正式步骤MacOS安装sdccMacOS下安装sdcc是非常简单的，使用brew一键安装就ok 了 12/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; #安装brewbrew install sdcc #安装sdcc 编译时，只需要使用sdcc sourcefile.c即可完成编译 安装配置VSCode安装完了编译环境，自然也需要一个代码编辑器。在这里，我选用了Visual Studio Code来作为编辑器 进入官网，下载并安装 安装完成之后添加C/C++扩展 按下Shift+Command+P,选择C/C++:编辑配置,在includePath添加sdcc的头文件地址 12345678910111213141516171819202122&#123; \"configurations\": [ &#123; \"name\": \"Mac\", \"includePath\": [ \"$&#123;workspaceFolder&#125; /**\", \"$&#123;workspaceFolder&#125; /include\", \"/usr/local/Cellar/sdcc/3.9.0/share/sdcc/include/mcs51\", \"/usr/local/Cellar/sdcc/3.9.0/share/sdcc/include/**\" ], \"defines\": [], \"macFrameworkPath\": [ \"/Users/fzx172/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks\" ], \"compilerPath\": \"/usr/bin/clang\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" &#125; ], \"version\": 4&#125; 安装Stcgal编辑器和编译器都解决了，下面应该解决下载程序 安装Python3 1brew insall python3 修改python3为系统默认版本 打开.bash_profile，添加以下内容 12345678910111213141516# python_switchfunction python2_switch &#123; sudo unlink /usr/bin/python sudo ln -s /System/Library/Frameworks/Python.framework/Versions/2.7/bin/python /usr/bin/python chmod a+x /usr/bin/python echo -e \"Python2已部署\"&#125;function python3_switch &#123; sudo unlink /usr/bin/python sudo ln -s /Library/Frameworks/Python.framework/Versions/3.7/bin/python3 /usr/bin/python chmod a+x /usr/bin/python echo -e \"Python3已部署\"&#125; 保存后执行source ~/.bash_profile，即可快速进行python版本切换 安装stcgal 执行pip install stcgal即可安装 安装ttl下载器的驱动PL2303 CH340 到此，macOS的51开发环境便搭建完毕 Windows安装sdccWindwos下可以不适用包管理器，直接前往SourceForge下载安装即可 安装VSCode 进入官网，下载并安装即可 安装完成之后添加C/C++扩展 添加头文件 按下Shift+Ctrl+P,选择C/C++:编辑配置,在includePath添加sdcc的头文件地址 1234567891011121314151617181920&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\", \"C:/Program Files/SDCC/include\", \"C:/Program Files/SDCC/include/mcs51\", \"$&#123;workspaceFolder&#125;/include\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"intelliSenseMode\": \"msvc-x64\" &#125; ], \"version\": 4&#125; 下载烧录程序以及下载器驱动windows下官网有提供烧录工具和驱动，所以直接下载即可 这样，Windows下的开发环境便搭建好了，Enjoy！ 后记折腾了半天，终于将环境折腾好了，感觉一切都好，就是头发少 我爱单片机，单片机是我快乐 可不可以的话扫一下右边的码支持一下，我会挖更多的坑的","categories":[{"name":"MCS-51","slug":"MCS-51","permalink":"/categories/MCS-51/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"/tags/单片机/"}]},{"title":"J1900软路由折腾记","slug":"J1900-PVE-RouterOS-Installation","date":"2019-05-31T10:56:16.000Z","updated":"2019-06-21T03:13:56.346Z","comments":true,"path":"2019/05/31/J1900-PVE-RouterOS-Installation/","link":"","permalink":"/2019/05/31/J1900-PVE-RouterOS-Installation/","excerpt":"夏天到了，突然发现我的小米路由器3好像慢了很多。但是我的钱包却告诉我它还很流畅于是乎我看了一眼桌子上的J1900…… J1900:你不要过来啊","text":"夏天到了，突然发现我的小米路由器3好像慢了很多。但是我的钱包却告诉我它还很流畅于是乎我看了一眼桌子上的J1900…… J1900:你不要过来啊 前言 众所周知，北方是一个没有春秋的地方。众所又周知，学校的建设工作总是会在你在校的时候发出通知，却在你快要离校的时候开始建设，什么时候你离开校园了，学校也就建设好了。这两者加在一起，并不会是双倍的快乐。为什么呢，明明是我先的 吐槽归吐槽，夏天到了。以发烧著称的小米路由3逐渐开始发高烧。并出现了断流，网速不稳一系列并发症。身为医学狗的我，自然就要修理一番。正好，前段时间刚把J1900小主机弄起来，那为什么不直接用PVE弄一个软路由，然后桥接一下。再搞一下多拨什么的岂不是美滋滋。这回就是双倍的快乐了 前期的准备以及工具 一张PCI千兆网卡(我的主板只有一个网线口，只能再购买一块) 4G优盘一枚 可以正常使用apt的网络 一台可以使用ssh的电脑 J1900小主板 要进行的操作 用pve安装一个软路由系统 编译mentohust进行校园网的拨号 与小米路由器3桥接 进行校园网多拨 添加路由器定时任务，防止掉线 正式步骤软路由系统安装提到第三方的路由系统，首先想到的就是openwrt啦，在这里，我选择了X-WRT作为软路由的系统 下载系统镜像并解压在X-WRT的下载界面里选择x86 64bits (MBR dos)下载后并解压文件 将镜像写入到优盘内 注意，写入镜像会清除优盘的所有数据，请注意备份文件 Windows 下载etcher并安装 插入优盘，打开etcher，选择下载好的镜像并选择优盘写入 Linux &amp;&amp; Mac打开终端，输入以下命令 12diskutil list #查看电脑里优盘的路径，比如我的是disk4dd if=/Users/fzx172/Downloads/x-wrt-5.0-b201905172119-x86-64-combined-ext4.iso of=/dev/disk4 #写入镜像 镜像写入成功后可能会提示无法访问，忽略即可 PVE虚拟机的创建以及启动 打开PVE的后台，选择创建虚拟机，具体配置的话视情况而定即可 创建完成，将优盘插到主板上，选择点击添加&gt;USB设备，并选择你的优盘 添加成功后，启动虚拟机，按住ESC键直至出现引导界面 选择你的优盘作为启动设备，然后稍等片刻即可进入系统 将镜像写入系统磁盘中路由器的默认账户和密码分别是root和admin，登陆后执行以下命令 12fdisk -l #查看系统的磁盘，比如，我创建的磁盘为/dev/sda,U盘为/dev/sdbdd if=/dev/sdb of=/dev/sda #将镜像写入 此时重启拔掉优盘，路由系统便可以从硬盘启动 编译mentohust进行校园网的拨号硬件连接 由于我的主机只有一个网口，于是乎我单独购买了一块PCI千兆网卡用来连接校园网。 关闭虚拟机，进入虚拟机的硬件设置，添加一块网卡，桥接设备选择PCI网卡 启动虚拟机，发现系统可以识别到网络，但是无法正确连接，此时我们则需要编译mentohust来进行校园网拨号 编译mentohust 一开始我尝试使用macOS直接进行编译，然而经历了无数次尝(翻)试(车)之后,我跑路了。。。。。然而并没有后来发现了一个神奇的东西叫做docker，然后用docker编译成功了docker一时爽，一直docker一直爽 下载并安装docker 前往docker官网下载docker的安装包安装并打开 打开终端，依次执行以下命令 1234docker pull openwrtorg/packages-cci #拉取镜像docker images #查看当前镜像的ID ，比如我的是472dadf87bccdocker run --name openwrt -itd 472dadf87bcc /bin/bash #创建一个名为openwrt的容器docker exec -it openwrt /bin/bash #为当前容器分配一个伪终端 此时，编译的环境就ok了，下面我们就可以编译mentohust了 编译mentohust 教程和源代码，我参考了这位大佬的教程,将自己的膝盖奉上 下载并更新openwrt的源代码 下载代码的时候可能会相当慢，自备工具 在刚才的伪终端中，依次执行以下命令 1234567cd ~git clone https://git.openwrt.org/openwrt/openwrt.git #下载源码cd openwrt/./scripts/feeds update./scripts/feeds install -a git clone https://github.com/KyleRicardo/MentoHUST-OpenWrt-ipk.git package/mentohust ##下载mentohust源码make menuconfig # 配置make文件 配置make文件 在伪终端中，依次选择以下内容 123Target System &gt; x86 Subtarget &gt; x86_64 Network &gt; Ruijie &gt; mentohust ##使用空格键确定，即以模块方式编译 按TAB键保存，然后退出即可 编译文件 保存make文件之后，依次执行以下命令 123make tools/install V=s make toolchain/install V=smake package/mentohust/compile V=s 编译时间可能会比较长，请耐心等待 注意，编译的时间可能会比较长，如果想要多线程编译，那么请在上述命令前执行export FORCE_UNSAFE_CONFIGURE=1后再在make命令后添加-j参数 编译成功后，再次打开一个终端执行下列命令将文件导出即可 1docker cp openwrt://home/build/openwrt/bin/packages/x86_64/base/mentohust_0.3.1-1_x86_64.ipk ~/Desktop|- 在桌面上即可看见生成的安装包了 进行拨号 在PVE的后台管理界面启动openwrt的远程管理界面，获取当前ip 12service firewall stop #先关闭防火墙，否则可能会无法访问ifconfig 我们可以看到有两个ip，这里我们使用192.168.32.108的地址登录 使用浏览器登录软路由的后台管理界面，进行如下设置 123系统 &gt; 管理权 &gt; ssh访问允许 SSH 密码验证允许 root 用户凭密码登录 上传文件 1scp ~/Desktop/mentohust_0.3.1-1_x86_64.ipk root@192.168.32.108:/root 拨号 ssh 路由器后台，执行以下命令 123opkg install mentohust_0.3.1-1_x86_64.ipkifconfig ##查看当前连接校园网的网卡的名称mentohust -uyouraccount -pyourpassword -nyournetwork -d2 -a1 #不同学校的登录方式不同，需要多次尝试不同的参数 如果提示发送心跳包以保持在线，则证明拨号成功，倘若没有拨号成功，可以查看输出日志来判断什么问题 启用多拨 mentohust检测运行状态通过是加锁打开mentohust.pid文件，如果加锁成功则说明没有运行，反之运行。所以我们要修改mentohust.pid的文件名才能多拨同理，它的配置文件存放在/etc/mentohust.conf中， 我们还要修改mentohust.conf的文件名才能够保证每个拨号程序能够独立运行 修改代码的话可能会比较繁琐，甚至用有可能会出现编译错误。所以我们使用另一种方式来修改拨号文件 下载16进制编辑器16进制编辑器有很多，我在这里使用了iHex，可以直接去App Store 去下载。Win平台可以使用WinHex 修改mentohust程序文件 将mentohust文件复制到本地 1scp root@192.168.32.108:/usr/sbin/mentohust ~/Desktop 使用iHex打开文件，分别搜索mentohust.pid、mentohust.conf。并将其修改为1entohust.pid、1entohust.conf后保存。文件名为1entohust 重复以上的步骤，知道达到你想要的多拨数量 注意，使用16进制修改器修改时只能替换，不能添加字符! 将修改好的文件上传至路由器的/usr/sbin/下 1scp ~/Desktop/1entohust root@xxx.xxx.xxx.xxx:/usr/sbin 启用路由器的多拨功能 浏览器登录路由器管理后台，进行如下设置 12345678网络 &gt; 多拨 &gt;启用多拨多拨数量选择你想要的数量保存并应用网络 &gt; 接口 &gt; 设备配置修改接口为桥接的网卡Mac地址修改为一个固定值 #十分重要！！！保存并应用 一定要将几个虚拟网口的MAC修改成固定值！！！，否则重启后回因为网口Mac地址改变而导致拨号失败！！！ 拨号测试 重复上述步骤即可 创建开机自启和定时拨号任务 到这里，路由器拨号就成功了。但是，每次重启就要登录后台拨号，掉线后还要继续拨号。体验太差 开机自启 记录一下当前拨号成功的mentohust命令 ssh登录路由器后台，修改/etc/rc.local文件 将命令复制到文件里面保存即可 定时拨号 使用网页登录路由器后台，在定时任务中输入如下内容 1*/5 * * * * mentohust -u121212 -p1212121 -neth0 -d2 -a1 #每5分钟执行一次 如果定时任务没有启动的话，可以在终端执行service cron start启动定时任务功能 与硬件路由器连接 硬路由的系统我依旧采用了openwrt，不过大部分的路由器的设置方式是一样的 路由器设置浏览器后台登录管理界面，进行和WiFi有关的设置 取消dhcp 保存 连接将路由器上lan口和软路由的另一个网口相连，重启开机即可 enjoy放两个速度截图23333333~~~ 这速度只能以三个字形容，舒服了其实网速还可以再往上的，但是没有账号了 后记折腾了半天终于算是弄完了，撒个花庆祝一下并没有","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"Server","slug":"Server","permalink":"/tags/Server/"},{"name":"Router","slug":"Router","permalink":"/tags/Router/"}]},{"title":"J1900小主机の折腾记(一)","slug":"J1900-Little-Server-Installation-1","date":"2019-04-11T21:18:34.000Z","updated":"2019-05-31T03:42:52.000Z","comments":true,"path":"2019/04/12/J1900-Little-Server-Installation-1/","link":"","permalink":"/2019/04/12/J1900-Little-Server-Installation-1/","excerpt":"在咸鱼上发现了一块只卖100元的J1900主板，在思考了一分钟后将它买了下来。虽然成色有点伊拉克，但是100元要什么自行车买回来后折腾了一段时间，算是可以勉勉强强的使用了，特此记录一下，用以怀念我失去的头发","text":"在咸鱼上发现了一块只卖100元的J1900主板，在思考了一分钟后将它买了下来。虽然成色有点伊拉克，但是100元要什么自行车买回来后折腾了一段时间，算是可以勉勉强强的使用了，特此记录一下，用以怀念我失去的头发 前言小主机配置 部件 信息 CPU Intel(R) Celeron(R) CPU J1900 @ 1.99GHz 主板 Soyo SY-J1900 内存 4g DDR3 1333Mhz 存储 SAMSUNG PM961 128G Nvme Seagate 320GB 7200RPM HDD 8GB SATA SSD 准备工作 一台显示器 一块8G 以上的优盘 一个可以正常使用apt进行安装软件的网络校园网说多了都是泪 安装过程Proxmox的安装 一开始我是准备直接使用Proxmox提供的镜像文件将系统安装到8G的SATA 固态上，结果硬盘空间不够… 只能采用Plan B，先安装一个Debian，然后在Debian上安装Proxmox所需要的组件了常翻车已经报警 Debian的下载以及安装制作启动优盘 下载Debian镜像 使用etcher将镜像写入优盘写入优盘 插入优盘，进入主板的BIOS，将U盘设置成第一启动设备安装Debian 在系统启动的界面中选择Graphical Install 语言设置、地区设置、键盘设置中保持默认即可~~为了最大的兼容性 hostname中设置一个名称，保持默认也可 domain name设置一个域名，随便填写就可以 分别设置root账户的密码，新建一个账户并设置密码 时区保持默认即可 磁盘分区中，选择Guided-use entire disk,选择你所要安装的系统磁盘，如果分区ok的话，选择Finish partitioning and write changes to disk后确认即可 在Use a network mirror点击yes，选择一个国内的镜像原即可，http proxy保持默认即可 在participate in the package usage survey中选择no 在Software selection中，仅勾选SSH server、standard system utilities即可 将grub安装至系统磁盘中 安装完成后拔掉优盘后重启即可 注意：如果拔掉显示器后系统无法启动，可以按下图用75欧姆电阻分别连接5-10、4-9、3-8针脚即可实测100欧姆电阻也可以 Debian的初步配置以及Proxmox组件的安装apt的初步配置(删除CDROM镜像源) 使用root账户登录Debian，并执行以下命令 12dhclientvi /etc/apt/sources.list 将CDROM开头的镜像源删除并保存 更新软件源即可 12apt-get updateapt-get upgrade 安装网络组件并查看网址 这里可以登录路由器的后台来查看主机的地址，此处采用另一种方法 执行以下命令即可 12apt-get install net-toolsifconfig 将ip地址记好，下面就可以使用ssh来远程操作了 注意：由于Debian系统的限制，在这里使用新建的用户进行登录后再切换为root账户 Proxmox组件的安装 这里参考了Proxmox官方网站的安装教程 使用ssh远程连接至主机 修改hosts文件，添加本机地址 1234vi /etc/hosts#将127.0.1.1替换替换成主机地址保存即可hostname --ip-address#如果此时返回的是主机的ip地址，即为正常工作 安装Proxmox 执行以下命令 12345echo \"deb http://download.proxmox.com/debian/pve stretch pve-no-subscription\" &gt; /etc/apt/sources.list.d/pve-install-repo.listwget http://download.proxmox.com/debian/proxmox-ve-release-5.x.gpg -O /etc/apt/trusted.gpg.d/proxmox-ve-release-5.x.gpgapt update &amp;&amp; apt dist-upgradeapt install proxmox-ve postfix open-iscsi -yapt remove os-prober 等待安装完成后，使用电脑端浏览器访问https://youripaddress:8006 Google Chrome等浏览器可能会提示证书问题，无视直接访问即可 使用root账户登录后，即可进入下一步的设置 虚拟网卡的创建 使用root账户登录后台 点击当前主机节点，依次选择网络设备&gt;创建&gt;Linux Bridge 将虚拟网卡的桥接端口修改为物理网卡接口名称 将IP地址修改为当前主机网址 保存并重启主机即可 LVM逻辑卷的搭建以及系统的安装LVM逻辑卷创建123456fdisk -l #查看当前硬盘挂载状态##可以看到，这里有两块名称为`sdb`、`sdc`的硬盘，我们需要先将这两个硬盘创建PV卷pvcreate /dev/sdb /dev/sdc #创建PV卷vgcreate myvg /dev/sdb /dev/sdc #创建一个卷组lvcreate -L 4G -n ISO myvg #创建一个逻辑卷用来存放ISO镜像mkfs -t ext4 /dev/myvg/ISO #格式化ISO卷 将逻辑卷挂载至Proxmox中12345cd /media/mkdir ISOmount /dev/myvg/ISO ISOpvesm add lvm myvg --vgname myvg --content images pvesm add dir ISO --path /media/ISO --content ISO 此时打开后台网页管理界面，就可以发现创建的逻辑卷已经挂载上 创建虚拟机并安装 点击ISO存储节点，依次点击内容&gt;上传，将下载好的系统镜像上传 点击新建虚拟机，根据情况设置即可 新建完成后启动虚拟机，按照正常步骤安装系统即可 后记在这折腾了半天后，终于算是勉强能够使用了。为了准备前段时间的考试就一直鸽到了现在。 下一步的操作应该就是整一个软路由，当然，现在已经弄完了毕竟夏天到了，我那个小米路由3有点顶不住了。。。。","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"Server","slug":"Server","permalink":"/tags/Server/"}]},{"title":"一些个人博客の安全设置","slug":"Some-Security-Settings-on-Blog","date":"2019-03-22T19:19:43.000Z","updated":"2019-09-20T12:32:32.596Z","comments":true,"path":"2019/03/23/Some-Security-Settings-on-Blog/","link":"","permalink":"/2019/03/23/Some-Security-Settings-on-Blog/","excerpt":"废了九牛二虎之力将自己的小博客搭起来了，结果服务器天天被炸。。。。既然这样，那就进行一些安全设置，确保不会被炸掉","text":"废了九牛二虎之力将自己的小博客搭起来了，结果服务器天天被炸。。。。既然这样，那就进行一些安全设置，确保不会被炸掉 前言前段时间发现学生主机真的好便宜，忍不住入手了一个。既然入手了，那就搭一个博客吧。废了老半天将博客搭建了起来，本以为只需要经常并不是写一下文章就可以了。结果ssh连上去发现ssh 22端口被炸了几千回。。。。没有办法，只能采取一些措施了，防止哪天被爆破掉。。。当然，用一个比较强的密码也是可以的，主要是记性不好再进行一下安全设置岂不是双倍的快乐？ 主要采用的措施 创建一个git账户 分别为git 和root 账户设置不同的秘钥登录 只赋予git账户git权限 禁用账户的密码登录方式，只保留key登录方式 修改ssh 22端口为其他端口 启用HTTPS 开搞创建git账户，只赋予git权限 ssh上远程服务器，并执行以下命令来创建账户 123456## 在root账户下进行操作useradd gitpasswd git # 此处创建一个git账户的密码mkdir /home/gitchown git:git -R /home/gitsu git #切换为git账户进行操作 在git账户下创建blog.git 执行以下命令 1234mkdir ~/blogcd ~/bloggit init --bare blog.gitcd blog.git/hooks 在hooks下新建一个 post-receive文件，并添加以下内容 1git --work-tree=/home/blog/www --git-dir=/home/git/blog/blog.git checkout -f 赋予post-receive可执行的权限 1chmod a+x post-receive 修改nginx的配置文件指向/home/git/blog/www 按下Ctrl+D，切换当前git账户为root账户，并修改nginx.conf的文件配置 12# 不同的nginx安装方式可能nginx.conf的所在位置有所不同vi /etc/nginx/nginx.conf 找到http项，在里面添加以下内容12345server &#123; server_name xxxx.com; index index.html index.htm index.php default.html default.htm default.php; root /home/git;&#125; 分别为git和root账户添加不同的密钥 创建git账户的密钥 创建git账户的话可以不在秘钥中添加密码，以实现免密码同步在本地计算机上打开终端，依次执行以下命令 12345ssh-keygen -t rsa -C xx@xx.com # 你的GitHub邮箱~~也可以任意内容~~# 之后连续按3次回车，保存秘钥文件,文件默认在`~/.ssh/`下chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsascp ~/.ssh/id_rsa.pub git@xxxxx:~/.ssh # xxxxx 为你的服务器地址 使用root账户ssh连接到远程服务器，执行以下命令 12345su git cd ~/.ssh/mv id_rsa.pub authorized_keyschmod 600 authorized_keyscd .. &amp;&amp; chmod 700 .ssh/ 创建root秘钥 处于保险起见，我们为root账户再次创建一个秘钥，这次再秘钥中添加上密码，以保证安全 将当前git账户切换为root账户，然后执行以下命令 123456789cd ~ssh-keygen# 第一次回车，选定秘钥存放位置，保持默认即可# 第二三次回车，设置&amp;&amp;确认创建的秘钥的密码cd .sshmv id_rsa.pub authorized_keyschmod 600 authorized_keys cd .. &amp;&amp; chmod 700 .sshcat .ssh/id_rsa 将id_rsa的文件内容复制到本地，保存为key并设置权限为600 禁用密码登录并开启密钥登录 在root账户下执行以下命令 1vi /etc/ssh/sshd_config 修改 PasswordAuthentication 项为NO并去掉前方#号 保存并退出，重启ssh服务 1/etc/init.d/ssh restart 此时断开连接，再次登录会发现只能使用密钥登录了 注意：强烈建议先启用密钥登录，断开连接并使用密钥登录成功后再关闭密码登录不要问我为什么强烈建议这么干 只赋予git账户git的权限使用root连接上远程服务器，修改passwd文件 1vi /etc/passwd 将git后面的shell更改为/usr/bin/git-shell 保存并退出，此时输入切换git账户会报错并无法切换 报错是正常现象，不用担心 修改ssh默认22端口为其他端口 在远程服务器上修改sshd_config文件 1vi /etc/ssh/sshd_config 修改port为其他端口，端口号大于10000都可以 重新启动ssh服务 1/etc/init.d/ssh restart 重新断开连接，会发现使用ssh无法使用22端口登录，需要改为当前设定端口我号要没了 如果修改失败并且无法登录了，可通过服务器管理网页上的vnc连接来重复上述步骤进行修改 再次不要问我为什么知道 hexo中的配置修改 _config.yml,添加以下内容 123456# aaaa为你的服务器地址，bbbb为你的设置的端口号deploy: type: git repo: server: ssh://git@aaaa:bbbb/home/git/blog/blog.git branch: master 这样就可以执行hexo d 将本地文件推动到远程服务器上了 启用https登录HTTPS证书的话免费的有很多，在这里以使用Let’sEncrypt为例 Let‘s Enycrypt 的https的证书可以在 这个网站这里按照提示快速安装，这里以nginx Ubuntu16.04 LTS为例 在上述网站选择合适的系统类型，这里选择nginx、Ubuntu 16.04 LTS 并确定 点击确定，稍后的页面会给出安装的命令，复制到远程的服务器上运行即可 然后执行以下命令进行自动安装 1certbot --nginx 自动安装后再次访问主页面即可发现网页已经启用https了 启动https证书的自动续期 执行以下命令 1certbot renew --dry-run 后记折腾了一大堆，安全措施差不多就ok，当然，最保险的还是定期更换一下，以保证不会被黑掉 折腾的过程真的掉头发，想想下面该写点什么 我爱单片机，单片机使我快乐","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"Server","slug":"Server","permalink":"/tags/Server/"},{"name":"Blog","slug":"Blog","permalink":"/tags/Blog/"}]},{"title":"联想小新锐7000の黑苹果折腾记(二)","slug":"Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-2","date":"2019-02-17T17:20:22.000Z","updated":"2019-03-21T14:08:14.000Z","comments":true,"path":"2019/02/18/Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-2/","link":"","permalink":"/2019/02/18/Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-2/","excerpt":"经过上一次的折(翻)腾(车)，系统我们已经安装好了。下面我们进行苹果系统的调试工作注意，这个过程可能会多次翻车。一定要有耐心233333","text":"经过上一次的折(翻)腾(车)，系统我们已经安装好了。下面我们进行苹果系统的调试工作注意，这个过程可能会多次翻车。一定要有耐心233333 前言下面的修改工作可以分为以下几个部分，大家可以按需阅读233333不过我还是建议通读一遍，以保证系统的稳定运行 将CLOVER系统文件移动到硬盘的EFI分区中屏蔽独显&amp;核显的驱动正确驱动核显修复亮度调节正确驱动声卡正确驱动网卡USB端口注入开启CPU变频启用睡眠 安装后的调试工作将CLOVER移动至系统EFI分区中 打开终端，输入以下命令来查看本地EFI引导的磁盘分区 1diskutil list 确定磁盘分区之后，输入以下命令。比如，我的磁盘EFI分区是disk0s2，优盘的EFI分区是disk4s2 12sudo diskutil mount disk0s2sudo diskutil mount disk4s1 打开访达，分别打开本地磁盘上的EFI分区以及优盘上的EFI分区 将CLOVER文件夹复制到磁盘的EFI目录下 在Windows下下载BOOTICE并打开 其实这里可以先在macOS下继续下面的操作，然后重启的时候再搞为什么不直接在Windows下搞呢？因为Windows下需要权限才能访问EFI分区。。 选择你EFI分区所在的磁盘，然后打开分区编辑选项 在分区管理页面里面选择ESP分区&gt;分配盘符然后确定就好 关闭分区管理，依次点击UEFI&gt;修改启动设置 然后在启动项修改页面中点击添加，选择EFI&gt;&gt;CLOVER&gt;&gt;CLOVERX64.efi 修改完成后保存并将其移动到最顶端 屏蔽独显&amp;核显的驱动 打开App Store ，搜索Xcode并安装 打开终端，依次输入以下命令 12345678cd Desktopmkdir Hackintosh_Project&amp;&amp;cd Hackintosh_Projectgit clone https://github.com/RehabMan/OS-X-Clover-Laptop-Config.gitgit clone https://github.com/acpica/acpica.gitcd acpicamake -j8 cd .. &amp;&amp; cd OS-X-Clover-Laptop-Config/hotpatchiasl SSDT-DDGPU.dsl SSDT-PNLF.dsl SSDT-IGPU.dsl SSDT-GPRW.dsl SSDT-PTSWAK.dsl SSDT-XOSI.dsl SSDT-ALS0.dsl 如果提示找不到iasl的话，可以使用下列命令安装后再次进入OS-X-Clover-Laptop-Config/hotpatch进行编译cd ~/Desktop/Hackintosh_project/acpia/ &amp;&amp; sudo make install我的电脑都编译的话莫名其妙会报错，所以只编译了一些需要的文件正常情况下直接在OS-X-Clover-Laptop-Config下执行make即可 分别下载Maciasl、下载 Clover Configurator、Hackintool，保存在桌面备用 将本地磁盘的EFI分区挂载，删除CLOVER/ACPI/patched 将 Hackintosh_Project/Hackintosh_Project/OS-X-Clover-Laptop-Config/hotpatch 下的 SSDT-DDGPU.aml SSDT-IGPU.aml 复制到CLOVER/ACPI/patched 打开Clover Configurator，然后选择EFI/CLOVER/config.plist 并进行以下操作后保存 ACPI:删除patches下的change PCI0.VID to IGPU #1 (Thinkpad)和change PCI0.VID to IGPU #2 (Thinkpad)Boot:删除-disablegfxfirmware参数Devices:删除所有Add Properties选项Graphics:取消勾选Inject ATI ,Injecr Nvdia选项SystemParameters:将inject Kexts修改为YES 点击Properties，并进行如下的设置 去掉#1 framebuffer-con1-alldata、#1 framebuffer-con1-enable、#framebuffer-con1-type前面的#号然后分别添加以下参数 Properties Key Properties Value Value Type disable-external-gpu 01000000 Data enable-hdmi20 01000000 Data framebuffer-portcount 02000000 Data 剩下的#号部分可以删除 重启即可完成独显的屏蔽以及核显的驱动。 倘若卡住无法进入系统，可以先将在clover引导界面中依次选择Opinions&gt;Graphics Injector将FakeID 改成0x12345678即可进入系统 亮度调节的修复 下载ApplebacklightFixup 将SSDT—PNLF.aml复制到EFI/CLOVER/ACPI/patched下 将AppleBacklightFixup.kext复制到EFI/CLOVER/kexts/Other下 复制Hackintosh_Project/OS-X-Clover-Laptop-Config/hotpatch下的SSDT-ALS0.aml到EFI/CLOVER/ACPI/patched下 下载Kext Utility,打开刷新缓存后重启即可修复亮度 倘若亮度没有修复，可以打开Kext Utility 并将ApplebacklightFixup.kext 拖入安装到S/L/E后重启即可 声卡的驱动 下载AppleALC 将AppleALC.kext复制到/EFI/CCLOVER/kexts/Other下 打开Clover Configurator，进行以下设置并保存 Devices:删除PciRoot(0x0)/Pci(0x1f,0x3)下的所有参数，新建项加入以下参数 Properties Key Properties Value Value Type layout-id 1C000000 DATA 用kext Utility刷新缓存重启即可 网卡的驱动 电脑自带的Realtek(或者Intel)无线网卡是无法驱动的，所以我更换了博通的BCM94352z无线网卡 下载BrcmPatchRAM和AirportBrcmFixup 将BrcmPatchRAM下的 BrcmFirmwareData.kext、BrcmPatchRAM2.kext 以及AirportBrcmFixup下的AirportBrcmFixup.kext复制到/EFI/CLOVER/kexts/Other下 用kext Utility刷新缓存重启即可 倘若出现睡眠后失灵的状况，可以将以上3个kext文件安装到S/L/E下即可解决 USB端口注入 打开hackintool，点击usb图标 分别用一个usb2.0与usb3.0的设备在电脑上的3个usb3.0的设备插拔一次 将非绿色的端口全部删除，即保留HS01、HS02、HS03、HS05、HS07、SS01、SS02 点击下方的Export图标，将生成的USBport.kext放EFI/CLOVER/kexts/Other下，并删除USBinjectAll.kext 将hotpatch下的SSDT-XOSI.aml 复制到/EFI/CLOVER/ACPI/Patched下 修改config.plist，在ACPI:Patched 添加以下内容（可以从hotpatch下的config.plist复制) Comment Find Replace change _OSI to XOSI, pair with SSDT-XOSI.aml 5F4F5349 584F5349 刷新缓存并重启即可 CPU变频开启 打开终端，执行以下命令 123cd ~/Desktop/Hackintosh_Projectgit clone https://github.com/acidanthera/CPUFriend.gitcp /System/Library/Extensions/IOPlatformPluginFamily.kext/Contents/PlugIns/X86PlatformPlugin.kext/Contents/Resources/Mac-B4831CEBD52A0C4C.plist ~/Desktop/Hackintosh_Project/CPUFriend/ResouceConverter 打开Xcode编辑Mac-B4831CEBD52A0C4C.plist进行以下修改 在Root&gt;IOPlatformPowerProfile中添加以下选项 Key Type Value power_reduced_playback Boolean Yes thermally_optimized_xcode Boolean Yes thermally_optimized_maps Boolean Yes optimized_photobooth Boolean Yes optimized_screensavers Boolean Yes optimized_slideshows Boolean Yes optimized_visualizers Boolean Yes 在Frequencies 中添加一行键值为3800在FrequencyVectors 复制其中一行的键值，index与Frequencies中的3800相对应，并将第二组数据改成08000000他们看起来是这个样子的 打开终端执行以下命令 1234cd ~/Desktop/Hackintosh_Project/CPUFriend/ResouceConverter./ResourceConverter.sh --kext Mac-B4831CEBD52A0C4C.plist./ResourceConverter.sh --acpi Mac-B4831CEBD52A0C4C.plistsudo cp Mac-B4831CEBD52A0C4C.plist /System/Library/Extensions/IOPlatformPluginFamily.kext/Contents/PlugIns/X86PlatformPlugin.kext/Contents/Resources/Mac-B4831CEBD52A0C4C.plist 新建终端，执行以下命令 123curl -o ~/ssdtPRGen.sh https://raw.githubusercontent.com/Piker-Alpha/ssdtPRGen.sh/Beta/ssdtPRGen.shchmod +x ~/ssdtPRGen.shsudo ~/ssdtPRGen.sh 编辑生成的ssdt.dsl文件，将刚才生成的ssdt_data 中的cf-frequency-data复制到Method (_DSM, 4, NotSerialized)中，并Package（0x02）改为Package（0x04），将文件保存为aml后退出 将刚修改的ssdt.aml复制到/EFI/CLOVER/ACPI/Patched中，将CPUFriend.kext、CPUFriendProvider.kext放到/EFI/CLOVER/kexts/Other里 刷新缓存重启即可 启用睡眠 将前文中编译的SSDT-GPRW.aml SSDT-PTSWAK.aml 复制到/EFI/CLOVER/ACPI/Patched中 用CloverConfigurator打开config.plist,在ACPI/Patched中添加如下选项(可以从hotpatch下的config中复制) Comment Find Replace change Method(_PTS,1,N) to ZPTS, pair with SSDT-PTSWAK.aml 5F505453 01 5A505453 01 change Method(_WAK,1,N) to ZWAK, pair with SSDT-PTSWAK.aml 5F57414B 01 5A57414B 01 change Method(GPRW,2,N) to XPRW, pair with SSDT-GPRW.aml 47505257 02 58505257 02 保存重启即可 注意：倘若之前在BIOS中关闭了显卡，可能会导致启动时卡在+++不动 显示器EDID的注入 使用HDMI的时候可能会导致笔记本屏幕黑屏，可以通过注入edid解决 打开hackintool，点击显示器，设置一个合适的屏幕类型点击屏幕下方的+号添加分辨率后再点击生成按键 将生成的DisplayVendorID-6af放到/System/Library/Displays/Contents/Resources/Override 下即可 刷新缓存并重启即可 如果无效或者启动后显示屏黑屏，可以考虑外接显示器或者进入恢复模式删除edid文件 后记 EFI 地址:Github 到这里黑苹果调试的差不多了，就可以使用了。当然还有很多地方没有修复，以后会慢慢修复的。。。 一时咸鱼一时爽，一直咸鱼一直爽","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"/tags/MacOS/"},{"name":"系统安装","slug":"系统安装","permalink":"/tags/系统安装/"}]},{"title":"联想小新锐7000の黑苹果折腾记(一)","slug":"Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-1","date":"2019-02-12T16:47:34.000Z","updated":"2019-03-22T05:05:11.000Z","comments":true,"path":"2019/02/13/Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-1/","link":"","permalink":"/2019/02/13/Hackintosh-Installation-on-Lenovo-Xiaoxin-Rui7000-1/","excerpt":"在经历了让人头秃的期末考试之后，终于可以着手继续折腾黑苹果了2333333经过无数次翻车与删库跑路之后，终于调整成了可以使用的样子，特此记录一下下，怀念我失去的头发。。。。","text":"在经历了让人头秃的期末考试之后，终于可以着手继续折腾黑苹果了2333333经过无数次翻车与删库跑路之后，终于调整成了可以使用的样子，特此记录一下下，怀念我失去的头发。。。。 前言电脑配置明细 部件 信息 CPU Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz 内存 8g DDR4 2400Mhz x2 存储 TOSHIBA Xg3 256G Nvme TOSHIBA 1TB 5400RPM HDD 显卡 Intel HD Graphics 630 NVIDIA GeForce GTX 1050 声卡 Realtek ALC235 有线网卡 Realtek RTL8111 PCI-E Gigabit Ethernet Adapter 无线网卡 Broadcom BCM94352z 802.11ac Wireless Network Adapter 系统截图 已知问题 亮度快捷按键调节不可用 亮度的最后一档相当于黑屏 FaceTime &amp; IMessage 不可用 (可以自己手动洗白) 适用于的系统 macOS High Sierra 10.13.6 macOS Mojave 10.14 准备工具 容量大于等于8G的优盘 笔记本电脑 网线(或者使用手机开启USB网络共享) 系统镜像是采用的黑果小兵大佬制作的macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606镜像，在这里感谢黑果小兵大佬教程可能会比较啰嗦，希望大家能够体谅一下233333部分网站可能需要加速才能顺利访问，自备工具 安装前的准备工作下载MacOS系统安装镜像以及启动盘的制作 在Windows下下载macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606镜像 下载etcher并安装 插入优盘，打开etcher，选择下载好的镜像并选择优盘写入 注意，写入镜像会清除优盘的所有数据，请注意备份文件 Windows下macOS虚拟机的创建 下载并安装VirtualBox 打开VirtualBox，点击管理&gt;全局设定&gt;扩展，安装扩展程序(需要将许可拉到最底下才能同意) 新建MacOS的虚拟机并将硬件设置中的核心数以及内存占用适当调大一些 在Mac虚拟机的设置&gt;USB设备中添加制作好系统镜像的优盘 打开CMD窗口，并输入以下命令 1234567891011121314# Mac为你所创建的虚拟机名称cd &quot;C:\\Program Files\\Oracle\\VirtualBox&quot;VBoxManage.exe modifyvm &quot;Mac&quot; --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbffVBoxManage setextradata &quot;Mac&quot; &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; &quot;iMac11,3&quot;VBoxManage setextradata &quot;Mac&quot; &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemVersion&quot; &quot;1.0&quot;VBoxManage setextradata &quot;Mac&quot; &quot;VBoxInternal/Devices/efi/0/Config/DmiBoardProduct&quot; &quot;Iloveapple&quot;VBoxManage setextradata &quot;Mac&quot; &quot;VBoxInternal/Devices/smc/0/Config/DeviceKey&quot; &quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot;VBoxManage setextradata &quot;Mac&quot; &quot;VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC&quot; 1 设置完成之后启动虚拟机，在EFIshell中输入exit进入BIOS进行设置 依次选择Boot Maintenance Mamager&gt;&gt;Boot From File&gt;&gt;”\\,xxxxxxxxxx(不是EFI)”&gt;&gt;System&gt;&gt;Library&gt;&gt;CoreService&gt;&gt;boot.efi稍等片刻即可进入安装界面 MacOS系统的安装 选择简体中文后在弹出的MacOS使用工具中选择磁盘工具 抹掉相应的磁盘(不知道那一块硬盘可以先选择显示所有宗卷) 完成后关闭磁盘工具，选择安装MacOS 一路下一步，选择安装到刚才抹掉的磁盘中后请耐心等待重启 重启后再次进入BIOS中选择Boot Maintenance Mamager&gt;&gt;Boot From File&gt;&gt;”\\,xxxxxxxxxx(带有SATA字样)”&gt;&gt;MacOS Install Data&gt;&gt;Locked Files&gt;&gt;Boot Files&gt;&gt;boot.efi并耐心等待 安装完成后便进入系统自定义设置部分，一路下一步即可 注意：在自定义设置中尽量不要连接网络 Clover 的安装 将优盘挂载到虚拟机中 打开终端并输入以下命令 1diskutil list 找到你优盘的EFI分区的 IDENTIFIER ，例如，我的是disk2s1，则输入以下命令 1sudo diskutil mount disk2s1 将EFI 里的文件复制到桌面备用并删除优盘EFI分区的文件 下载Clover并打开 选择安装到你的优盘中 点击自定，并依次勾选以下设置 仅安装UEFI开机版本安装RCScripts到目标磁区UEFIDrivers和 FileVault2 UEFIDrivers中勾选下列选项 AptioMemoryFix-64.efi DataHubDxe-64.efi HFSPlus.efi SMCHelper-64.efiAppleImageLoader-64.efi AudioDxe-64.efi EmuVariableUefi-64.efi NvmExpressDxe-64.efi VirtualSmc.efiAptioInputFix-64.efi CsmVideoDxe-64.efi FSInject-64.efi OsxAptioFix3Drv-64.efi 检查无误后点击确定，输入密码安装即可 EFI文件的初步配置 下载HoRNDIS并放到优盘EFI分区下(安装系统完成之后进行安装) 下载 Clover Configurator 保存到桌面备用 打开终端，依次输入以下命令 1234cd Desktopmkdir project &amp;&amp; cd projectcurl -O https://raw.githubusercontent.com/RehabMan/OS-X-Clover-Laptop-Config/master/config_HD615_620_630_640_650.plistcurl -O https://github.com/Erf172/Lenovo_XiaoXin_Rui7000_Hackintosh/raw/10.13/CLOVER/drivers64UEFI/ApfsDriverLoader-64.efi 打开project,复制config_HD615_620_630_640_650.plist到优盘的EFI&gt;&gt;Clover下并将其改名为config.plist 打开 Clover Configurator，选择优盘EFI目录下的config.plist文件依次进行以下的设置并保存 Boot&gt;Arguments 中右键添加”-v -debug=0x100 -nv_disable=1”选项Devices 中删除所有Add Properties选项Graphics 取消Inject ATI、Inject NVIDIA选项SMIBIOS 设置成MacBook Pro14,1 分别下载以下文件，并放到EFI&gt;&gt;Clover&gt;&gt;kexts&gt;&gt;others VirtualSMC.kextSMCBatteryManager.kextUSBInjectALL.kextLilu.kextWhateverGreen.kextVoodooPS2Controller.kextRealtekRTL8111.kextApplePS2SmartTouchpad.kextNoTouchID.kext 将project下的ApfsDriverLoader-64.efi与VirtualSMC文件夹下的VirtualSMC.efi复制EFI&gt;&gt;Clover&gt;&gt;drivers64UEFI下 最后，他们看起来应该是这个样子的 压缩磁盘，分出相应的安装空间 右击计算机，依次点击管理&gt;磁盘管理 右击你想要压缩的磁盘，选择压缩卷，在弹出来的对话框中选择合适的大小(建议不小于40G)并点击确定 右击压缩出现的空白区域，选择创建简单卷，一路下一步即可 至此，黑苹果前期的准备工作就OK了，下面将进入正式的安装阶段 Bios的相关设置 用以下三种方法中的一种进入电脑的bios 在关机的状态下用尖锐物品按一下右侧的重启按键开机的时候狂按F2或者Fn+F2在Windows 10中，按住shift键并点击重启，依次点击高级选项&gt;UEFI固件设置 在进入的Bios界面中依次设置以下选项 Security&gt;Secure Boot&gt;Disabled Boot&gt;Boot Priority Order&gt;优盘选项移动到最顶端 确认设置无误后，按下F10或者Fn+F10进行保存。如果一切正常的话，就可以引导进入Clover的引导界面 正式的安装步骤 在Clover BOOT引导界面中，选择Boot OS X Install From xxx(xxx为你的优盘名称) 稍等片刻即可进入安装过程，此过程的安装步骤与在虚拟机的安装步骤相似，参考上文进行安装即可 安装完成后会自动重启，再次进入Clover的引导界面，会发现多出几个选项，选择安装Boot OS X install From yyy(非优盘项) 下面便进入自动安装的过程，可能会重启几次，耐心等待即可。 安装完成后再引导界面选择boot macOS from xxx(xxx为你的安装磁盘名称名称) 稍等片刻进入个性化设置阶段，视情况设置即可 设置完成之后进入桌面，至此，黑苹果的系统安装完毕。 后记至此为止，我们的安装阶段就完成了。恭喜你已经完成了一个小小的开头。因为进入系统后，你可能会发现这只是安装了系统而已，什么东西都是残的。什么功能都是不完整的。你可能会怀疑人生，为什么折腾这么久才完成了一个小小的开头。不要慌张，不要心急，最麻烦的地方不在于安装系统，而是对EFI文件进行调整。在下一篇文章中，我将会告诉大家如何进行系黑苹果配置工作。让他能够更加完美。为什么不分开来写呢，应为调整的过程实在是太长了，如果一篇文章写下来的话，可能我连自己写下去的耐心都不会有。才不是为了凑一下文章的数目下一篇文章我会尽快写完的坚决不是flag.jpg 传送门 ： 联想小新锐7000の黑苹果折腾记(二)","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"/tags/MacOS/"},{"name":"系统安装","slug":"系统安装","permalink":"/tags/系统安装/"}]},{"title":"Linux不能正常安装或启动の部分解决方法","slug":"how-to-slove-Linux-cannot-boot","date":"2018-12-01T11:25:19.000Z","updated":"2019-03-10T06:54:01.000Z","comments":true,"path":"2018/12/01/how-to-slove-Linux-cannot-boot/","link":"","permalink":"/2018/12/01/how-to-slove-Linux-cannot-boot/","excerpt":"前段时间安装Linux。结果安装过程各种各种报错接踵而来。。。查了半天资料，问题也解决的差不多了。特此记录一下下。","text":"前段时间安装Linux。结果安装过程各种各种报错接踵而来。。。查了半天资料，问题也解决的差不多了。特此记录一下下。 适用情况这篇文章适用于以下问题的解决方案 无法进入安装界面，疯狂刷“pci bus error“等类似的错误信息 安装完成后，启动时无法进入桌面。 进入桌面后重启/注销卡住，无法正常重启/注销 更新了内核或一些软件后出现以上的问题 以下的解决方法均以Manjaro 18.0为例。不同Linux发行版的操作方式大同小异 解决方法A————禁用nouveau报错的原因有一部分是因为Linux自带的nouveau驱动存在问题，所以才会导致安装出现上述问题。所以，我们只要将其自带的驱动禁用掉即可解决 安装过程禁用 在优盘引导安装的界面中，不要直接进行安装。移动到BOOT：xxx 后，按一下e键进入grub的编辑模式 在grub的编辑模式中，找到Linux的那一行，在最后面添加一下信息 1modprobe.blacklist=nouveau 添加完成后，按下Ctrl+X或者F10 进行安装。便可以进行正常的安装 第一次启动安装后可以按照以上操作步骤进行操作即可进入桌面 （或者如果是因为更新造成的问题，可以在grub引导界面中选择低版本的内核启动） 进入启动过程后修改启动文件 打开终端，修改 /etc/default/grub 1sudo vi /etc/default/grub 在 GRUB_CMDLINE_LINUX_DEFAULT 行中添加以下内容并保存 1modprobe.blacklist=nouveau 修改完成后更新grub引导 1sudo update-grub 至此系统便可以正常使用了 解决方法B————安装较低版本内核如果上面的方法不好使，可以使用一下的方法进行解决 进入Bios设置，禁用独立显卡、无线网卡按照正常安装方式进行安装进入系统桌面后，手动安装Linux 4.9.x版本的内核并重启至此系统便也可以正常使用了 后记上面的解决方法，个人感觉第一种方法解决的比较彻底。第二中我也用过一段时间（4.9的内核苟了大半年。。。），感觉只可以临时解决问题，并不是长久之计。 （不是所有的电脑都能完美的安装Linux，现在这句话我是信的233333） 第二篇文章终于写完了，差不多就这样吧。下篇文章再见！ (写点什么好呢。。。。)","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"系统安装","slug":"系统安装","permalink":"/tags/系统安装/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"删除优盘病毒の不完全教程","slug":"how-to-remove-virus-from-udisk","date":"2018-11-28T20:41:53.000Z","updated":"2018-11-29T09:23:06.000Z","comments":true,"path":"2018/11/29/how-to-remove-virus-from-udisk/","link":"","permalink":"/2018/11/29/how-to-remove-virus-from-udisk/","excerpt":"今天去打印店打印东西。回来后发现自己的优盘又中病毒了。。。。（等等，我为什么说又。。。）既然中毒了，那么就得清理一下。。。。。","text":"今天去打印店打印东西。回来后发现自己的优盘又中病毒了。。。。（等等，我为什么说又。。。）既然中毒了，那么就得清理一下。。。。。 将资源管理器设置成显示所有文件 打开我的电脑&gt;&gt;查看&gt;&gt;选项 在打开的文件夹选项中取消“隐藏受保护的系统文件(推荐)”并选择“显示所有文件和文件夹” 删除病毒 右击打开被感染的优盘，一定要右击，防止中病毒 将快捷方式删除掉，还有那个病毒.exe 将文件夹及文件设置成可见 在打开的盘界面中按住shift键右击，选择在“此处打开命令窗口/powershell” 输入以下命令 1attrib * -s -h -r -a /D 至此，优盘的病毒就会清理干净了。 注意事项 优盘不要直接打开，不要直接打开，不要直接打开。 优盘一定要点击右键&gt;&gt;打开 如果电脑不小心中毒，最好重装系统，360什么的杀不净的。 后记一直想要出一个怎么清理优盘病毒的教程，毕竟学校是这种东西的高发区。。。但是我总是遇不到。。。 其实这两天想要填一下坑的，谁知道半路杀出一个程咬金。不过也好把这个教程出了。。 继续填坑去了","categories":[{"name":"Guide","slug":"Guide","permalink":"/categories/Guide/"}],"tags":[{"name":"优盘","slug":"优盘","permalink":"/tags/优盘/"},{"name":"删除病毒","slug":"删除病毒","permalink":"/tags/删除病毒/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-25T08:52:48.000Z","updated":"2019-02-16T12:16:03.000Z","comments":true,"path":"2018/11/25/hello-world/","link":"","permalink":"/2018/11/25/hello-world/","excerpt":"你好，欢迎来到我的小站在这里我将会不定期更新一些教程，一些翻车时刻，还有一些杂七杂八的东西 请使用IE，360极速浏览器访问的同学或使用较低操作系统版本的同学移步Chrome或Firefox。 部分素材来自互联网，如有侵权请与fzx172@126.com联系删除！","text":"你好，欢迎来到我的小站在这里我将会不定期更新一些教程，一些翻车时刻，还有一些杂七杂八的东西 请使用IE，360极速浏览器访问的同学或使用较低操作系统版本的同学移步Chrome或Firefox。 部分素材来自互联网，如有侵权请与fzx172@126.com联系删除！ 下面便是填坑时间了，慢慢填坑中。。。。。。 关于这不是lD ，一所普普通通的大学中的一名普普通通的大二医学狗。 喜欢折腾电脑，肥宅一枚，休伯利安洗甲工一枚。 日常咸鱼，有时折腾，时常翻车。 本站使用Material X作为主题，喜欢这个主题的朋友可以阅读文档进行安装哦。","categories":[{"name":"Others","slug":"Others","permalink":"/categories/Others/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"/tags/置顶/"},{"name":"欢迎","slug":"欢迎","permalink":"/tags/欢迎/"}]}]}